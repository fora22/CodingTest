'''
제임스가 일하는 사무실에는 문서를 한 번에 하나씩 인쇄할 수 있는 프린터 한 대가 있습니다. 혼자 프린터를 사용할 때는 별 문제가 없지만, 여러 사람이 동시에 프린터를 사용할 때는 어떤 문서를 먼저 인쇄할지 정해야 합니다. 일반적인 프린터의 경우 먼저 요청된 문서를 먼저 인쇄하지만, 제임스는 보다 효율적인 일처리를 위해 다음과 같이 프린터가 인쇄 요청을 처리하는 규칙을 정했습니다.

1. 인쇄 중 또는 대기 중인 문서가 없을 때 인쇄 요청된 문서는 즉시 인쇄합니다.
2. 인쇄 중 또는 대기 중인 문서가 있을 때 인쇄 요청된 문서는 대기열에 추가합니다.
3. 인쇄 중인 문서가 전부 인쇄된 후 대기열에서 다음 문서를 선택해 인쇄합니다.
    3-1. 대기 중인 문서중 페이지 수가 적은 문서부터 인쇄합니다.
    3-2. 대기 중인 문서중 페이지 수가 같은 문서가 있을 경우, 먼저 요청된 문서부터 인쇄합니다.
    3-3. 현재 인쇄 중인 문서의 인쇄가 끝난 시각과 새로 요청된 문서의 인쇄 요청 시각이 같은 경우, 새로 요청된 문서를 먼저 대기열에 추가한 후 다음에 인쇄해야 될 문서를 선택합니다.

제임스는 프린터가 규칙대로 작동하는지 테스트하기 위해 가상의 인쇄 요청 데이터를 만들어 입력해보려 합니다. 각 인쇄 요청 데이터는 다음과 같은 형식입니다.
    [문서 번호, 인쇄 요청 시각, 페이지 수]

단, 인쇄 요청 시각은 0초부터 시작하며, 초 단위로 나타냅니다. 예를 들어 어떤 문서의 인쇄 요청 데이터가 [2, 2, 4]인 경우, 이는 2번 문서가 2초에 인쇄 요청됐으며, 4페이지를 인쇄해야 된다는 의미입니다. 또한 한 페이지를 인쇄하는 데에는 1초가 걸립니다.

인쇄 요청 데이터들이 들어있는 배열 data가 매개변수로 주어질 때, 배열에 인쇄가 완료되는 순서대로 문서 번호를 담아 return 하도록 solution 함수를 완성해주세요.

제한사항
    data는 가로(열) 길이가 3, 세로(행) 길이가 1 이상 100,000 이하인 2차원 배열입니다.
    data의 원소는 [문서 번호, 인쇄 요청 시각, 페이지 수] 형식입니다.
        인쇄할 문서가 N개일 때, 모든 문서에는 1부터 N까지 번호가 하나씩 붙어있습니다.
        data의 각 행은 문서 번호와 인쇄 요청 시각이 증가하는 순서로 주어집니다.
        즉, data의 각 행의 문서 번호는 1부터 N까지 오름차순 형태로 주어지며, 번호가 클수록 나중에 인쇄 요청된 문서입니다.
        인쇄 요청 시각이 같은 문서는 없습니다.
        인쇄 요청 시각은 0 이상 100,000,000 이하인 자연수입니다.
        페이지 수는 1 이상 100,000 이하인 자연수입니다.
    문서를 대기열에 추가하거나, 다음 인쇄할 문서를 선택하는데 걸리는 시간은 없다고 가정합니다.
'''
from collections import deque
import heapq

def solution(data):
    answer = []
    time = 0
    queue = deque(data)
    heap = []
    currentQueue = []       # 현재 인쇄중인 문서 데이터를 담는 Queue / 현재 Queue는 항상 한 개의 데이터만 있음
    
    while queue or heap:    # queue나 heap이 다 비어지면 while문 stop
        if queue and (queue[0][1] == time):     # queue 안에 데이터가 있으며, 인쇄요청시각 == 현재시각에 해당될때 queue에서 데이터를 꺼냄
            printDoc = queue.popleft()
            heapq.heappush(heap, (printDoc[2], printDoc))   # 최소(페이지 수) heap에 push 함 / heap에서 페이지 수가 최소가 될 수 있도록 (페이지 수, raw_data) 모양의 튜플을 push
        
        if not(currentQueue) and heap:          # 현재 Queue가 비어있고, heap에 데이터가 있다면 heap에서 데이터를 꺼내어 현재 Queue에 집어넣음
            currentQueue.append((time, heapq.heappop(heap)[1]))

        if currentQueue and ((currentQueue[0][0] + currentQueue[0][1][2] - 1) == time):     # 인쇄 시작시간 + 페이지 수 == 현재 시각과 같다면, 현재 Queue에서 Pop하여 문서 인쇄 종료
            printQueue = currentQueue.pop()
            answer.append(printQueue[1][0])

        time += 1
        
        
    answer.append(currentQueue[0][1][0])        # 마지막 현재 Queue에 담겨있는 문서 번호를 answer에 append
    return answer

d = [
    [[1, 0, 5],[2, 2, 2],[3, 3, 1],[4, 4, 1],[5, 10, 2]],
    [[1, 0, 3], [2, 1, 3], [3, 3, 2], [4, 9, 1], [5, 10, 2]],
    [[1, 2, 10], [2, 5, 8], [3, 6, 9], [4, 20, 6], [5, 25, 5]]
]

for i in range(3):
    print(solution(d[i]))